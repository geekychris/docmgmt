# LazyInitializationException Fix

## Problem

When creating a root folder from the UI, the following error occurred:

```
org.hibernate.LazyInitializationException: failed to lazily initialize a collection of role: 
com.docmgmt.model.Folder.childFolders: could not initialize proxy - no Session
```

### Root Cause

The `Folder` entity had lazy-loaded collections (`childFolders`, `items`, `parentFolder`) that were included in the `equals()` and `hashCode()` methods generated by Lombok's `@EqualsAndHashCode` annotation. When these methods were called outside of a Hibernate session (e.g., when the entity was stored in a HashMap or compared), Hibernate tried to load the lazy collections but no session was available.

## Solution

### 1. Exclude Lazy Collections from equals/hashCode

**File**: `src/main/java/com/docmgmt/model/Folder.java`

Changed:
```java
@EqualsAndHashCode(callSuper = true)
@ToString(callSuper = true)
```

To:
```java
@EqualsAndHashCode(callSuper = true, exclude = {"parentFolder", "childFolders", "items"})
@ToString(callSuper = true, exclude = {"parentFolder", "childFolders", "items"})
```

**Rationale**: 
- Prevents Hibernate from trying to load lazy collections during equals/hashCode computation
- These relationship fields should not be part of entity identity anyway
- The entity's ID (from SysObject) is sufficient for equality checks

### 2. Initialize Lazy Collections in Service Methods

**File**: `src/main/java/com/docmgmt/service/FolderService.java`

Updated the following methods to initialize lazy collections:

#### `findById(Long id)`
```java
@Override
@Transactional(readOnly = true)
public Folder findById(Long id) {
    Folder folder = super.findById(id);
    // Initialize all lazy collections
    if (folder.getPermissions() != null) {
        folder.getPermissions().size();
    }
    if (folder.getContents() != null) {
        folder.getContents().size();
    }
    if (folder.getChildFolders() != null) {  // ADDED
        folder.getChildFolders().size();
    }
    if (folder.getItems() != null) {         // ADDED
        folder.getItems().size();
    }
    if (folder.getParentVersion() != null) {
        folder.getParentVersion().getName();
    }
    return folder;
}
```

#### `findRootFolders()`
```java
@Transactional(readOnly = true)
public List<Folder> findRootFolders() {
    List<Folder> folders = repository.findByParentFolderIsNull();
    // Initialize lazy collections (ADDED)
    folders.forEach(folder -> {
        if (folder.getChildFolders() != null) {
            folder.getChildFolders().size();
        }
        if (folder.getItems() != null) {
            folder.getItems().size();
        }
    });
    return folders;
}
```

#### `findChildFolders(Folder parentFolder)`
```java
@Transactional(readOnly = true)
public List<Folder> findChildFolders(Folder parentFolder) {
    List<Folder> folders = repository.findByParentFolder(parentFolder);
    // Initialize lazy collections (ADDED)
    folders.forEach(folder -> {
        if (folder.getChildFolders() != null) {
            folder.getChildFolders().size();
        }
        if (folder.getItems() != null) {
            folder.getItems().size();
        }
    });
    return folders;
}
```

#### `findAll()`
```java
@Override
@Transactional(readOnly = true)
public List<Folder> findAll() {
    List<Folder> folders = super.findAll();
    // Initialize all lazy collections
    folders.forEach(folder -> {
        if (folder.getPermissions() != null) {
            folder.getPermissions().size();
        }
        if (folder.getContents() != null) {
            folder.getContents().size();
        }
        if (folder.getChildFolders() != null) {  // ADDED
            folder.getChildFolders().size();
        }
        if (folder.getItems() != null) {         // ADDED
            folder.getItems().size();
        }
        if (folder.getParentVersion() != null) {
            folder.getParentVersion().getName();
        }
    });
    return folders;
}
```

**Rationale**:
- Ensures collections are loaded within the transaction boundary
- Prevents lazy initialization exceptions when entities are used in the UI layer
- Uses `.size()` to trigger collection loading without fully loading all elements

## Why This Pattern Works

1. **@Transactional**: All service methods that return entities are marked with `@Transactional(readOnly = true)`, which provides a Hibernate session for the duration of the method call.

2. **Eager Initialization**: By calling `.size()` on each lazy collection while still inside the transaction, we force Hibernate to load the collection data.

3. **Exclude from equals/hashCode**: By excluding lazy collections from equality checks, we prevent Hibernate from trying to load them when entities are compared or stored in hash-based collections outside of a session.

## Alternative Approaches Considered

### 1. Use `@Fetch(FetchMode.JOIN)` or `fetch = FetchType.EAGER`
**Rejected**: This would always load all related data, even when not needed, leading to performance issues and the N+1 query problem.

### 2. Use DTO pattern everywhere
**Rejected**: While DTOs are good for API responses, they add significant boilerplate for internal operations. The current approach is simpler for the UI layer.

### 3. Use `@EntityGraph` annotations
**Considered for future**: This is a more sophisticated approach that allows fine-grained control over what to fetch. Could be implemented if specific performance issues arise.

## Testing

### Unit Tests
All FolderViewTest tests pass:
```
✅ testFolderServiceReturnsRootFolders
✅ testCreateFolderFlow
✅ testAddChildFolderFlow
✅ testAddDocumentToFolderFlow
✅ testRemoveItemFromFolderFlow
✅ testFindByIdReturnsFolder
✅ testDocumentServiceReturnsLatestVersions
```

### Integration Tests
Run `FolderHierarchyIntegrationTest` when the application is not running:
```bash
mvn test -Dtest=FolderHierarchyIntegrationTest
```

### Manual Testing
1. Start the application: `mvn spring-boot:run`
2. Navigate to: `http://localhost:8082/docmgmt/folders`
3. Click "New Root Folder"
4. Fill in folder details and create
5. Verify folder appears in tree without errors

## Similar Issues in Other Entities

The same pattern (excluding lazy collections from equals/hashCode) is used in:
- **SysObject**: excludes `parentVersion` (already fixed)
- **Document**: no lazy collections to exclude
- **Folder**: now excludes `parentFolder`, `childFolders`, `items`

If you add new entities with lazy collections, remember to:
1. Exclude lazy collections from `@EqualsAndHashCode` and `@ToString`
2. Initialize collections in service methods that return entities
3. Ensure all service methods are `@Transactional`

## Summary

The fix addresses the LazyInitializationException by:
1. Preventing Hibernate from accessing lazy collections during equals/hashCode operations
2. Eagerly initializing collections within transaction boundaries when entities are returned from service methods
3. Maintaining lazy loading benefits (data not loaded until needed) while avoiding session issues

This is a standard pattern in JPA/Hibernate applications and follows best practices for entity management.
